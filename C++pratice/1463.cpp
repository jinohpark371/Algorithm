#include <iostream>
#include <algorithm>
using namespace std;

int dp[1000001];

/*
2의 배수는 2로 나눈 연산, 3의 배수는 3으로 나누는 연산과 조건 없이 1을 뺄 수 있는 연산
이렇게 3개만 존재한다.
그러면 2의 배수인 수는 자신의 이전 숫자 즉 1을 뺀 수의 최소 연산횟수에서 자신이 이전 수가 되기 뺴기 연산횟수 1을 추가한 값과
2의 배수에서 2로 나눠서 자신을 만들기 위해 직전에 어떤 수에 자기 자신의 연산이 추가되어 1증가 된 값
이렇게 두개를 비교하여 가장 작은 값이 자신의 최소연산횟수가 될 수 있다.
3의 배수 또한 마찬가지이며
2와 3의 배수에서는 1을 뺐던 숫자의 최소 연산 횟수+1, 2로 나누어 나온 직전 숫자의 최소연산횟수 +1, 3으로 나누어 나온 직전 숫자의 최소연산횟수 +1
이 3개의 값을 비교하여 가장 작은 값이 자신의 최소 연산이 됨

2의 배수가 아니거나 3의 배수가 아닌 수 1을 뺴는 연산 밖에 못하므로 자신의 이전 숫자에서 +1한 값만 가질 수 밖에 없다
*/

int main() {
	int num, count;
	count = 0;
	cin >> num;
	//dp[i]는 i번째 수를 1로 만들기 위한 최소 연산 횟수
	dp[1] = 0;
	//dp[1]은 그냥 1이므로 연산 횟수는 0
	for (int i = 2; i < num + 1; i++) {
		dp[i] = dp[i - 1] + 1;


		if (i % 2 == 0) dp[i] = min(dp[i], dp[i / 2] + 1);
		if (i % 3 == 0) dp[i] = min(dp[i], dp[i / 3] + 1);
	}
	cout << dp[num];
	return 0;
}