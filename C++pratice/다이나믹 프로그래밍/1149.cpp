#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
int d[1000][3]; // d[i][j] : i번째 집을 j색으로 칠했을 때의 최소 누적 비용
int r[1000]; int g[1000]; int b[1000]; // 각 집을 R/G/B로 칠했을 때의 비용
int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) cin >> r[i] >> g[i] >> b[i];

	// 초기값: 첫 번째 집은 각 색을 바로 칠한 비용
	d[0][0] = r[0];
	d[0][1] = g[0];
	d[0][2] = b[0];

	//dp의 각 값은 자신을 선택했을때 이전 줄의 자신의 색을 제외한 가장 작은 색의 값을 더한 값
	//각 행의 dp값은 색이 겹치지 않고 구할 수 있는 비용들의 모든 경우의 수
	for (int i = 1; i < n; i++) {
		d[i][0] = r[i] + min(d[i-1][1], d[i-1][2]);
		d[i][1] = g[i] + min(d[i-1][0], d[i-1][2]);
		d[i][2] = b[i] + min(d[i-1][0], d[i-1][1]);
	}
	//결국 마지막 행에서 그동안 쌓아놨던  조건을 만족하면서 쌓았던 dp값으로 이전 행의
	//dp값을 이용해 마지막 행의 dp값들을 계산하고 가장 작은 값이 조건을 만족하는 최소비용
	//각 행은 이전 행의 dp값을 보고 계산하기만 하면 됨
	cout << min({ d[n - 1][0],d[n - 1][1], d[n - 1][2] });


	//DP로 푸는 핵심은 이전 단계에서 이미 최적을 골라놨으니 다음 단계에선 그걸 기반으로 최적을 확장!!
	return 0;
}
